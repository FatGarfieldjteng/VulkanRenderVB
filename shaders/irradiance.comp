#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform samplerCube environmentMap;
layout(set = 0, binding = 1, rgba16f) uniform writeonly image2DArray irradianceMap;

const float PI = 3.14159265359;

vec3 getCubeDir(ivec3 coord, float size) {
    vec2 uv = (vec2(coord.xy) + 0.5) / size * 2.0 - 1.0;
    switch (coord.z) {
        case 0: return normalize(vec3( 1.0, -uv.y, -uv.x));
        case 1: return normalize(vec3(-1.0, -uv.y,  uv.x));
        case 2: return normalize(vec3( uv.x,  1.0,  uv.y));
        case 3: return normalize(vec3( uv.x, -1.0, -uv.y));
        case 4: return normalize(vec3( uv.x, -uv.y,  1.0));
        case 5: return normalize(vec3(-uv.x, -uv.y, -1.0));
    }
    return vec3(0.0);
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID);
    int size = imageSize(irradianceMap).x;
    if (coord.x >= size || coord.y >= size || coord.z >= 6) return;

    vec3 N = getCubeDir(coord, float(size));
    vec3 up = abs(N.y) < 0.999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);
    vec3 right = normalize(cross(up, N));
    up = cross(N, right);

    vec3 irradiance = vec3(0.0);
    float nrSamples = 0.0;
    float sampleDelta = 0.05;

    for (float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta) {
        for (float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta) {
            vec3 tangentSample = vec3(
                sin(theta) * cos(phi),
                sin(theta) * sin(phi),
                cos(theta));
            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N;

            irradiance += texture(environmentMap, sampleVec).rgb * cos(theta) * sin(theta);
            nrSamples++;
        }
    }
    irradiance = PI * irradiance / nrSamples;

    imageStore(irradianceMap, coord, vec4(irradiance, 1.0));
}
